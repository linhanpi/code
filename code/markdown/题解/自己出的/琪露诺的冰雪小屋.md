### 前置芝士

* [P4482 Border 的四种求法——静态链分治](https://www.luogu.com.cn/blog/AlexWei/solution-p4482)
* [CF1437G Death DBMS——$\text{dfs}$ 解除子树限制](https://www.luogu.com.cn/blog/AlexWei/solution-cf1437g)
* [P6580 美好的每一天~ 不连续的存在——按操作代价分块](https://www.luogu.com.cn/problem/P6580)

芜湖\~起飞！

### 算法一

只有一次询问是经典的静态链分治。

先明确在处理每个点 $x$ 的时候要求出所有 $\operatorname{lca}(i,j)=x$ 的点对的贡献。

这样前面的限制有了好看的形式：$a_j\operatorname{xor}b_x=c_i$。

那以朴素的 $\text{dsu\ on\ tree}$ 的做法，可以将这些点对分为两部分。

**1. $i$ 是 $x$ 的轻子树 $y$ 中的点，$j$ 在除了 $y$ 以外其他所有子树内**

为了统计 $w_i$，可以开个桶 $cnt$ 统计某个子树内 $a_i$ 的出现次数。

$cnt$ 是一个天然的子树信息，可以在 $\text{dfs}$ 的同时处理。

但是为了 $j$ 不在 $y$ 的子树内，可以先将 $y$ 子树对 $cnt$ 的影响删去，查完后再加回。

由于 $x$ 是固定的，每个 $y$ 子树内的点 $i$ 直接查询 $cnt_{c_i \operatorname{xor} b_x}$ 的值即可。

可以直接利用重子树的桶查询，最后再合并。

一个点最多 $\log n$ 次成为轻子树中的点，这一部分时间复杂度 $\mathcal{O}(n\log n)$。

**2. $i$ 是 $x$ 的重子树 $y$ 中的点，$j$ 在轻子树内**

每个轻子树内的点 $j$ 对重子树内的点的影响：**在 $son_x$ 的子树内的，$c_i=a_j\operatorname{xor} b_x$ 的点的 $w_i+1$**。

如果没有子树限制，直接再开个桶，在每个 $c_j\operatorname{xor}b_x$ 处 $+1$，最终对每个 $i$ 统计 $c_i$ 被加了多少次。

但即使加上子树限制，也可以简单地通过 $\text{dfs}$ 解决。

具体地把所有修改离线下来挂在子树地根上，然后进行一次 $\text{dfs}$ 计算贡献，每次进入子树时在桶上修改，离开子树时撤销。

这一部分的时间复杂度和修改的总次数相关，一共会有 $\sum 轻子树大小$ 次修改，所以这部分的时间复杂度也是 $\mathcal{O}(n\log n)$ 的。

### 算法二

我会回滚莫队！

不增加莫队在这道题会好写一些，以下约定右指针只减而左指针可撤回。

每次跳指针时分裂连通块，不妨设现在分裂出了一块以 $x$ 为根原来以 $y$ 为根的连通块，
