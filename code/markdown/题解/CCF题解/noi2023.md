> 没这个实力你知道吧

种树大赛，每道题都和树相关。

## A 方格染色

$100 / 100$

---

看 B 性质，没有斜线时是经典的扫描线。

考虑到斜线只有 $5$ 条，拉出来用 map 暴力去重。

有点难写。

## B 桂花树

$35/50$

检查的时候看了还一眼要不要取模，一看 $(3\times 10^4)^2\le 10^9+7$，然后选择没管它，挂了 15pts。

---

改写限制

第一个条件等价于 $1\sim n$ 构成的虚树等于它本身。

第二个条件等价于对于每个 $1\le i\le n+m$,$1\sim i$ 构成的虚树中不能有大于 $i+k$ 的结点。

感觉第二个条件转化后很有前途，顺着做下去，在从小到大加入结点的同时维护当前前缀的虚树，虚树上可能有一些未确定的结点，它们是在确定一个节点 $i$ 时作为 $i$ 在虚树上最近的 $\mathrm{lca}$ 被加入的，会在以后的转移中被确定。

一个未确定的节点最多不会超过加入它的节点 $i$ 加上 $k$ 的值，并且最多会有一个未确定的节点在确定 $i$ 时被加入，可以记录当前是否有未确定的不能大于 $i+k$ 的点在虚树上，这个状态可以用一个 $k$ 二进制数来表示。

不妨设当前已经确定了 $1\sim i$，未确定结点状态为 $S$，虚树上结点数为 $c=i+\operatorname{popcount}(S)$，分讨得出以下四种转移：

* 把 $i+1$ 挂在一个虚树上的结点上作为叶子，方案数为 $c$
* 把 $i+1$ 放在虚树上一条边上，方案数为 $c-1$
* 把 $i+1$ 填入之前某个未确定的结点，枚举 $S$ 每个 $i$ 转移
* 在虚树上的某条边上钦定一个不能超过 $i+k+1$ 的未确定的点，把 $i+1$ 挂在这个结点上作为叶子

直接转移 $\mathcal{O}(mk2^k)$。

* 树上很多 $\operatorname{lca}$ 相关限制可以改写到虚树上。

## C 深搜

神题

$36/36$

冲了 $1.5h$ 64pts，没冲出来及时止损。

---

### 打暴力

首先，根据无向图 $\text{dfs}$ 树的性质，$T$ 可以作为 $G$ 的 $\text{s-dfs}$ 树的充要条件为树上没有以 $s$ 为根的横插边。

称非树边 $e$ 覆盖点 $u$ 当且仅当 $e$ 在以 $s$ 为根的 $T$ 上是横插边。

可以得到 $e=\{u,v\}$ 不覆盖点 $s$ 当且仅当 $s$ 在以 $u$ 为根的 $v$ 子树中或者以 $v$ 为根的 $u$ 子树中。

设 $c(S)$ 表示不覆盖关键点集 $S$ 中的任意点的边的数量，设关键点全集为 $U$，容斥可以得到 $ans=\sum_{|S|\geq 1,S\in U}(-1)^{|S|+1}2^{c(S)}$，直接算可以拿到 36pts。

### 建虚树

* 称一个点属于虚树上当且仅当它是虚树的结点。
* 称一个点落在虚树上当且仅当它是虚树上的结点或被虚树上的边包含。

由于只和一些特定的关键点相关，把点 $1$ 作为原树的根，建出 $S$ 的虚树 $T_S$，特殊的，$S$ 中所有点的 $\text{lca}$ $d$ 如果不属于 $S$ ，且 $d$ 在虚树上的儿子只有两个，那么它不属于这颗虚树。

重新考虑合法非树边的形态，有以下两种情况：

* 这条边是落在虚树上的一个点 $u$ 向虚树外延伸的子树中的一条返祖边。
* 这条边完全被虚树上的一条边包含。

注意到由于我们特殊考虑了所有点的 $\text{lca}\ d$，第二种情况中可能会含有覆盖 $d$ 的合法横插边，不是很好处理。

### 性质B

这条性质限制了不存在覆盖 $d$ 的合法横插边，可以去掉对 $d$ 的特殊考虑，直接把 $d$ 加入虚树中不影响答案。

枚举 $d$，此时合法边分为了 $d$ 的子树内外两大部分，互相不会影响，可以直接相乘。

* 子树内的贡献可以利用虚树的结构 dp，设 $f_i$ 表示 $i$ 是虚树的根时 $i$ 子树内对答案的贡献。
* 子树外的贡献可以通过一遍换根 dp 求出 $i$ 子树内的返祖边个数 $in_i$ 和子树外的个数 $out_i$，则子树外的贡献为 $2^{out_i}$。

将 $d$ 原树上的儿子分成两类，$son_i$ 落在虚树上的和其他。

设 $d$ 落在虚树上的儿子集合为 $P$，如果将贡献系数直接统计为 $\prod_{p\in P}f_p$，会有一些合法的边没有被统计到，分讨后有以下三种：

* 第一类合法边：对于 $p\in P$，包含于路径 $d\rightsquigarrow p$ 上的边。
* 第二类合法边：对于 $p\in P$ 和所有 $ d\rightsquigarrow p$ 路径上的点（不含 $d$），向虚树外延伸的子树内的返祖边。
* 第三类合法边：每个不落在虚树上的原树上 $d$ 的儿子 $q$，$q$ 子树内的返祖边（可以返到 $d$）。

此时可以分讨两种原树上的儿子分别的贡献系数。

如果 $son_i$ 落在虚树上，它的贡献系数为 $X(son_i)$，否则贡献系数为 $Y(son_i)$。

**从贡献系数推出 $f_d$**

设 $h_i$ 表示 $d$ 有 $i$ 个儿子落在虚树上时的贡献系数，可以用一个背包求出。

* 若 $d\in S$，要求 $d\in U$，则落在虚树上的儿子树任意，对 $f_d$ 产生贡献 $-\sum h_i$（此处负号表示将 $d$ 加入 $S$）。
* 若 $d\notin S$，则至少 $d$ 有两个儿子要落在虚树上，对 $f_d$ 产生贡献 $\sum_{i\geq 2} h_i$。

注意到 $i\geq 2$ 的 $h_i$ 等价，可以只维护 $h_0,h_1$ 和 $\sum_{i\geq 2} h_i$。

**$X(son_i)$ 的求法**

设 $g_{p\rightarrow d}$ 表示 $f_p\times 2^c$，其中 $c$ 等于包含于路径 $d\rightsquigarrow p$ 的合法边以及所有路径 $d\rightsquigarrow p$ 上的点（不含点 $d,p$）向虚树外旁逸斜出的合法边数量。

显然 $X(son_i)=\sum_{p\in \text{subtree}(son_i)}g_{p\rightarrow d}$。

通过维护 $g_{p\rightarrow d}$ 计算 $X(son_i)$。

* 先继承子树信息：$g_{p\rightarrow d}\leftarrow g_{p\rightarrow son_i}$。
* 然后加入儿子贡献：$g_{son_i\rightarrow d}\leftarrow f_{son_i}$。
* 加入第一类合法边贡献：枚举 $d$ 连向子树内的非树边 $(d,u)$，产生使 $u$ 子树内的所有 $g$ 值 $\times 2$ 的贡献。
* 加入第二类合法边贡献：枚举 $son_i$ 连向子树内的非树边 $(son_i,u)$，假设 $u$ 对应的 $son_i$ 的儿子为 $v$，产生对 $son_i$ 所有非 $v$ 的儿子子树内 $p$ 值 $\times 2$ 的贡献。

全程只涉及区间乘法，区间求和，子树修改，用 $\text{dfs}$ 序为下标的线段树维护。

**$Y(son_i)$ 的求法**

$Y(son_i)=2^c$，其中 $c$ 等于与 $son_i$ 相关的第三类合法边的数量，利用 $in_{son_i}$ 很容易数出来。

复杂度 $\mathcal{O}(n\log n)$。

### 正解

多出了一些以 $d$ 为根的合法横插边。

考虑先去掉原来的贡献 $F_2\times 2^{out_d}$（注意到现在背包需要区分 $F_2$），然后把正确的贡献算回来。

不妨设 $d$ 在虚树上两个儿子是 $p,q$，设它们对应的 $d$ 的儿子分别为 $u,v\ (u\neq v)$，原来计算的贡献是 $z=g_{p\rightarrow d}\times g_{q\rightarrow d}\times \prod _{son_i\neq u,v}Y(son_i)$，现在要加入两端点分别在 $p\rightsquigarrow d$ 和 $q\rightsquigarrow d$ 上的横插边 $(x,y)$ 的贡献，每有一条这样的边就把 $z\times 2$。

先将 $son_i$ 子树内所有 $g$ 值乘上 $\dfrac{1}{Y(son_i)}$，最后把贡献乘上 $\prod Y(son_i)$，这样在计算过程中就和 $u,v$ 无关了。

把所有 $g\times g$ 放在二维平面上，枚举 $d$，则一条 $\text{lca}$ 为 $d$ 的横插边的贡献是将一个矩形 $\times 2$，经过若干次矩形 $\times 2$ 后全平面求和，可以扫描线维护，注意容斥掉 $u=v$ 的贡献。

时间复杂度 $\mathcal{O}(n\log n)$。

## D 贸易

$100/100$

---

枚举 $\operatorname{lca}$，分别统计上下行贡献相乘即可。

## E 字符串

$100/72$

CCF 是全 $\texttt{a}$ 串都懒得造。

没啥高论，少了个 $key\ observation$。

---

字典序比较考虑后缀数组，正串反串拼一起，查下 $rk$ 比大小，是二维偏序形式。

然后你不想写 $height$ 数组判相等，观察一下发现相等当且仅当构成回文串，把所有回文串拉出来暴力去重是 $\mathcal{O}(n^2)$ 的。期望得分 72pts，~~实际上是 100pts~~。

$\text{key\ observation}$：一个极长回文串内部所有回文串会要么全都会被算重，要么全都不会，会被算重当且仅当回文串左边外侧的字符大于右边的。

有了这个结论，一个回文串只会对一个矩形内的询问产生 $-1$ 的贡献，扫描线 + $\text{BIT}$ 维护做到 $\mathcal{O}(n\log n)$。

## F 合并书本

$20/10+??$

谁来教教我写 50pts 的模拟颓火吖

---

合并操作考虑建出操作树。

对于一个点 $x$，定义 $a_x$ 表示它向上合并时对答案产生名义为重量的贡献的系数。

$\text{observation\ 1}$：如果我们已知重量贡献系数的多重集 $S=\{a\}$，问题就转化为已知 $a,w$，要求排列 $p$，使得最小化 $\sum w_i\times a_{p_i}$。经典问题，由排序不等式，将 $a,w$ 分别升$/$降序排列匹配即可。这说明我们并不关心子树内的 $w_i$ 集合。

定义一个点的层级 $d_i$ 为两个儿子中较大的层级 $+1$，那么一个非根非叶子结点会对答案产生名义为磨损值的贡献 $2^{d_i}-1$。

因为每一个更深的层级会对它上方的所有点产生 $\times 2$ 的影响，考虑从上往下确定这棵树，同时记录当前的磨损值总贡献 $c$ 和叶子上的重量贡献系数多重集 $S$。

定义一次 “分裂” 过程为生成两个叶子挂在一个当前的叶子下面，假设这个叶子的重量贡献系数为 $x$，这两个叶子的系数分别为 $x$ 和 $x+1$，可以发现确定树的过程相当于做 $n-1$ 次分裂操作。

钦定每次分裂所有最终层级为 $k$ 的叶子，那么每次分裂会让当前所有结点层级数 $+1$，假设当前分裂了 $x$ 个叶子，那么它的贡献为将当前的 $c$ 变为 $2\times c+x-2$。

考虑每次分裂 $S$ 会怎么变，还是假设当前分裂了 $x$ 个叶子，需要选中 $S$ 的一个子集 $T$ 使得 $|T|=x$，对于所有 $t\le T$，将 $t+1$ 加入 $S$ 中，根据前面的讨论可知，如果确定了 $x$，那么磨损值的贡献就确定了，现在只需要最小化 $S$ 中的数，那么 $T$ 必定是 $S$ 中前 $x$ 小的数构成的（感性理解一下，不太会证）。

现在的状态数是划分数级别的。

$\text{observation\ 2}$：每次分裂的 $x$ 单调不降。由于我们每次钦定分裂所有层级为 $k$ 的叶子，一个结点如果层级 $k$，那么它的儿子至少有一个层级为 $k-1$，会在下一轮操作中被分裂。

$\text{observation\ 3}$：由于 $x$ 单调不降，那么以前贡献的 $c$ 越小，留给以后的发挥空间反而越多，相当于对于 $S$ 相等的状态只需保留 $c$ 最小的。同样的，、，上一轮操作的叶子个数 $x$ 也只用保留最少的。

在写一些 sb 剪枝，实测 $n\le 100$ 时，只有 $44863$ 个状态，可以通过。

代码很好写。
