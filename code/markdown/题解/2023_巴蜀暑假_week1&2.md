## AGC039F Min Product Sum

此类计数问题可以将 $f$ 的构造方式作为切入口，思考如下的暴力：钦定一组和 $f$ 构成**双射**的 $g$，并求得其权值 $w$ 和对应 $A$ 的方案数 $S$，则这组 $g$ 对答案的贡献为 $w\times S$，然后将这个过程优化。

容易发现 $f$ 数组的构造只和行列的最小值有关，记 $x_i,y_i$ 分别为 $i$ 行和列的最小值。

若 $x,y$ 已知，权值容易求出为 $\prod_{i}\prod_{j}\min\{x_i,y_j\} $。这个过程是 ${ \mathcal{O}(nm)}$ 的，可以通过**从小到大**加入元素优化到 ${ \mathcal{O}(n+m)}$：每次加入 $x,y$ 中最小的元素，假设此时已经加入了 $i$ 行 $j$ 列，那么如果这次加入的 $t$ 来自行贡献为 $t^{m-j}$ 否则为 $t^{n-i}$，正确性显然。

枚举 $x,y$ 后权值可以确定，还要计算满足 $A$ 的行列最小值恰好为 $x,y$ 的数量。不好直接做，把**恰好**容斥掉，求出 $A$ 的行列最小值**大于等于** $x,y$ 的方案数，枚举一定大于的行列，套用超集反演得出最终结果。

设 $dp_{t,i,j}$ 表示已经加入了 $x,y$ 中小于等于 $t$ 的元素，已经加入了 $i$ 行 $j$ 列的所有可能情况的贡献之和。转移时枚举钦定被容斥的行和列，一次性加入**所有相同属性**的行列，用多重组合数还原成有序的。

枚举加入了 $a$ 个**不被容斥**的行：

$$
dp_{t,i+a,j}\leftarrow g_{i,j}\cdot\begin{pmatrix}n-i\\a\end{pmatrix}\cdot(K-t+1)^{aj}\cdot t^{a(m-j)}
$$

枚举加入了 $b$ 个**不被容斥**的列：

$$
dp_{t,i,j+b}\leftarrow g_{i,j}\cdot\begin{pmatrix}m-j\\b\end{pmatrix}\cdot(K-t+1)^{bi}\cdot t^{b(n-i)}
$$

枚举加入了 $c$ 个**被容斥**的行：

$$
dp_{t,i+c,j}\leftarrow g_{i,j}\cdot\begin{pmatrix}n-i\\c\end{pmatrix}\cdot(K-t)^{cj}\cdot t^{c(m-j)}
$$

枚举加入了 $d$ 个**被容斥**的列：

$$
dp_{t,i,j+d}\leftarrow g_{i,j}\cdot\begin{pmatrix}m-j\\d\end{pmatrix}\cdot(K-t)^{di}\cdot t^{d(n-i)}
$$

$g$ 表示**上一枚举阶段**转移完后的的 $dp$ 数组。

时间复杂度 ${ \mathcal{O}(Knm(n+m))}$。

题解中提供了不需要容斥的做法，但是~~蒟蒻我不会~~拓展性不高，就不记录了。

## CF335F Buy  One, Get One Free

反悔贪心。

按照**从大到小**的顺序枚举馅饼，因为白嫖的机会是**较大的**馅饼**给予**的。

考虑贪心，设此时枚举到的价格为 $i$ 的馅饼有 $cnt_i$ 个，比当前馅饼价格贵的有 $num_i$ 个，以前的贪心中已经白嫖的有 $q$ 个，当前价格可以直接白嫖的馅饼有 $p$ 个，容易得出以下关系：

$$
p=\min\{num_i-2\times q,cnt_i\}
$$

分析反悔策略，每次可以购买一个之前已经被白嫖的馅饼，这个馅饼会带来 $2$ 次白嫖机会：自己的和释放的以前某个被购买的馅饼的。每次取出当前价值最小的价值被白嫖的馅饼，假设价值为 $k$，按照以上反悔策略，把 $res=2\times i-k$ 加到已白嫖的集合里就好了。

用堆维护时间复杂度 ${ \mathcal{O}(n\log n)}$。

??说好的反悔贪心都可以模拟费用流呢??

## CF1707D Partial Virtual Trees

正着加不好做就**倒着删**。

对题面中这样的满足**连续的子集关系**的一组集合的计数可以转化为在时刻 $t$ 把某些元素从集合中**删除**的过程。

先分析集合满足限制的充要条件：如果一个点不在集合内，那么它只有一个儿子的子树内可以有集合内的点，讨论这个点是否是 LCA 容易得出。

设 $f_{u,j}$ 表示 $u$ 的子树内直到 $j$ 时刻仍然有点亮的点的方案数，转移时枚举 $u$ 在 $j$ 时刻仍然点亮和熄灭两种情况讨论。

若 $j$ 时刻 $u$ 仍被点亮，直接从子树转移：

$$
dp_{u,j}\leftarrow \prod_{v\in son_u}\sum_{k=0}^{j}f_{v,j}
$$

若 $j$ 时刻 $u$ 已经熄灭，枚举 $u$ 被熄灭的时刻，假设为 $p$ 到 $p+1$，那么 $p+1$ 到 $j$ 时刻**有且仅有** $u$ 的一个子树内的点可以点亮：

$$
dp_{u,j}\leftarrow\sum_{p=0}^{j-1}\sum_{v\in son_u}f_{v,p}\prod_{\omega\in son_u \wedge \omega \neq v}\sum_{t=0}^{p}f_{\omega,t}
$$

以上过程可以用前缀和优化可以做到 ${ \mathcal{O}(nk)}$。

可以发现上面求出的方案数是**不满足**相邻时刻的集合**不等**的条件，**真子集**条件不太好改，把它容斥掉。设 $G(i)$ 为使用 $i$ 步将全集修改成 $\{1\}$ 且满足相邻集合**真子集**限制的方案数，$F(i)$ 为满足**子集**的方案数，寻找 $F$ 和 $G$ 之间的关系，枚举 $F$ 中满足真子集条件的位置有：

$$
F(i)=\sum_{j=1}^i\begin{pmatrix}i\\j\end{pmatrix}G(j)
$$

由二项式反演有：

$$
G(i)=\sum_{j=1}^i(-1)^{i-j}\begin{pmatrix}i\\j\end{pmatrix}F(j)
$$

按上面的式子算就好了，时间复杂度 ${ \mathcal{O}(n^2)}$。

## CF1687E Become Big For Me

**gcd-lcm 反演**，对每个质因子的幂次数施 min-max 容斥有：

$$
\gcd(S)=\sum_{T\in S}\operatorname{lcm}(T)^{(-1)^{|T|+1}}
$$

转化一下 $\gcd_{i\neq j}\{A_i,A_j\}$ ，变成每个质因数最小和**非严格**次小幂次的乘积。

### sol 1

要求用 lcm 构造出次小值，再对每个质因子的幂次数施**广义 min-max 容斥**并和原有的 gcd 合并有：

$$
\gcd_{i\neq j}\{A_i,A_j\}=\sum_{T\in S}\operatorname{lcm}(T)^{(-1)^{|T|}(|T|-2)}
$$

根据柿子直接构造是 ${ \mathcal{O}(2^n)}$ 的，一个经典结论是对于任意值域 $[1,10^6]$ 的集合 $S$ ，它总存在一个**大小不超过 $7$ 的子集** $T$ 满足 $\gcd(S)=\gcd(T)$，原因是一个 $10^6$ 以内的数最多有 $7$ 个质因子。构造就任选一个数，将其最小幂次对应的数加入集合，再检查这个数能否去除。

根据上述方法先选一次集合 $T$，从 $S$ 中将 $T$ 中的元素删除重新再选一次 $T'$，将 $T$ 和 $T'$ 合并构成的 $G$ 的答案和原有 $S$ 的答案相同且大小至多有 $14$ 个数。对 $G$ 用上面的办法构造可以通过。

### sol 2

蒟蒻不会广义 min-max 容斥怎么办？

不妨假设每个质因子的幂次次小值都不是**严格**次小的，那么答案变为 $\gcd\{S\}^2$ 容易构造。

分析怎么表示幂次最小值和幂次次小值间的差异，容易发现去掉幂次最小值后再求一遍 gcd 就是幂次次小值，所以答案可以表示为：

$$
\gcd(S)^2\prod_{i}\dfrac{\gcd_{j\neq i}\{a_j\}}{\gcd(S)}
$$

这样用 $7$ 个数构成的集合 $T$ 就可以构造了。

## CF1137F Matches Are Not a Child's Play

询问一个数在某个过程中的**排名**可以**拆贡献**转化为统计**在它前面的数**对它**产生贡献**的和。

最大的数总是最后被删除，把它拎成根。

分析什么样的点 $v$ 会对 $u$ 产生贡献，容易发现一个点总是在它的子树**最大值**后被删除，记 $maxn_u$ 为 $u$ 子树内的最大值，那么 $maxn_v<maxn_u$ 的点 $v$ 会对 $u$ 产生 $1$ 的贡献。

一次 up $x$ 相当于把 $x$ 给拎到根节点上，只会将 $x$ 到 $rt$ 路径上的 $maxn$ 全部变为 $maxn_{rt}$。

区间推平？珂朵莉树！先把树给重剖，对每个重链维护一颗珂朵莉树，开一个树状数组记录 $maxn$ 为 $x$ 的点的数量，随便维护一下就好，根据**势能分析**复杂度是对的,时间复杂度 $ \mathcal{O}(n\log^2 n)$。

## CF1054G New Road Network

构造可以往如何使一次构造满足**尽可能多**的条件的贪心想。

树上一条边的作用为将必须与 $x$ 和 $y$ 相连的点给联通起来，如果构造的方案**尽量多**得把必须与 $x$ 和 $y$ 相连的点给联通起来，那它就更**可能是最优解**。

由上面的思想我们可以构造一张完全图，图上 $x\rightarrow y$ 的边的边权为和 $x$ 在一个集合的点集与和 $y$ 在一个集合的点集的交的大小，对这张图跑最大生成树并 check 这棵树是否满足每一个集合的要求，时间复杂度 $ \mathcal{O}(\dfrac{n^3}{w})$。

## AGC029E Wandering TKHS

以下叙述中默认把 1 作为根。

分析会对 $x$ 的答案**产生贡献**的 $y$，可以发现当且仅当 $x$ 与 $y$ 的 lca $l$ 到根的**路径最大值** $>$ $y$ 到 $l$ 的路径最大值（不包含 $l$）。

容易发现我们只关心每个点 $y$ 到根节点且去掉点 $l$ 的路径，观察这条路径，设最大值为 $w$，如果去掉的**不是 $w$**，那么 $w$ 必定会出现在 $l$ 上方或下方的某一条链中，此时仅当 $w$ 出现在 $l$ 上方时 $y$ 产生贡献；还剩下 **$w$ 就是 $l$** 的情况，记录路径**次大值** $w'$ 并比较它与 $w$ 的位置关系判断能否被选取。

显然每个点 $y$ 可以产生贡献的点在一颗子树内，差分随便做一下就可以做到 $\mathcal{O}(n)$ 了。

## P6611 六元环

**平面图**上的东西可以先看看能不能用**三角剖分**表示。

按照题面中的**相邻**关系建出一张图 $G$，首先**大根笛卡尔树**上的边一定在 $G$ 中，另外节点 $x$ 的左儿子的右链和右儿子的左链上的节点都会和 $x$ 有边。

容易发现 $G$ 是一张无向图，六元环在平面图上可以由四个**相邻的三角形**组成。观察得到三角形一定是由一条在笛卡尔树上的边以及两条连接同一个祖先的不在笛卡尔树上的边构成，一个点最多连出**一条**到祖先节点的不在笛卡尔树上的边，每个三角形可以用最低的顶点表示，于是转化为了统计笛卡尔树上**联通的四个点**的方案数，可以统计一个点子树内下一层和下下层的节点数量简单计数。

修改只会将一个树**变大**，转化到笛卡尔树上表现为**上旋**的过程，对于一条**方向相同**的链，$x$ 上旋到链顶只会产生 $x,fa_x,top_x,son_x$ 总计 $\mathcal{O}(1)$ 的父子关系改变，使用 lct 维护套用它的势能分析可以得到 $\mathcal{O}(q\log n)$ 的复杂度。

思路就是这样，具体实现先等蒟蒻我研究完~~题解代码~~再放上来。

## CF1510H Hard Optimization

**区间不会交错**，仿照 [Helping People](https://www.luogu.com.cn/problem/CF494C "题面 link") 的 trick 建树。

分析选取方式，一个点代表的线段会被 $m$ 个儿子分成 $2m+1$ 个线段，其中有 $m+1$ 个没有被任何儿子覆盖，这个点的要么选取这 $m+1$ 段中的一段**向左向右延伸**，要么完全在某个儿子的**内部**。

树形 dp，设 $f_{u,k,pl,pr}$ 表示当前考虑 $u$ 的子树，从 $u$ 的祖先一共传下来 $k$ 个需要在 $[l_u,r_u]$ 内部选取的**祖先段的子段**，简称为**子段**，之所以被称为**子段**是因为这些段可能是祖先节点在选择不被儿子覆盖的段后左右延伸到儿子内部产生的段，当前节点的前 $/$ 后缀是否要与左 $/$ 右边合并的最优解长度。初始状态设定为对于每个叶子节点 $u$，$f_{u,0,0,0}=r_u-l_u$，可以发现叶子节点可以直接选取 $[l_u,r_u]$，且祖先在它内部选取**不会更优**。

转移到**非叶子节点** $u$ 时，先从左到右合并所有儿子，设 $g_{i,k,pl,pr}$ 表示合并到第 $i$ 个儿子，一共传下去了 $k$ 个子段（包括 $u$），$u$ 的前缀是否与左边合并，$v_i$ 的后缀是否与后面合并的最优解长度。枚举 $k_i,pl_i,pr_i$ 以及这个儿子左边的一段是否被**子段**覆盖进行转移。

$v_i$ 的左边**不被选择**时：

$$g_{u,k,pl,pr}\leftarrow \max_{k_i=0}^{k}\{f_{v_i,k_i,pl,0}+g_{i-1,k-k_i,0,pr}\}$$

$v_i$ 的左边**被选择**时：

$$f_{u,k,pl,pr}\leftarrow \max_{pl_i,pr_i}\max_{k_i=0}^{k-pl_i+pr_i-1}\{f_{v_i,k_i,pl,pr_i}+g_{i-1,k-k_i+pl+pr-1,pl_i,pr}+(l_{v_i}-r_{v_{i-1}})\}$$

转移上式时注意 $i=1$ 的边界情况要将最终的 $r_{v_{i-1}}$ 换成 $l_u$。

接下来还要考虑最后一个儿子右边的串会不会被选取：

$$f_{m+1,k,pl,0}\leftarrow g_{v_m,k,pl,0}$$

$$f_{m+1,k,pl,1}\leftarrow \max_{pr_i}\{g_{m,k+pr_i-1,pl,pr_i}+(r_u-r_{v_m})\}$$

最终要将 $g$ 合并到 $f$ 上，有简单关系：

$$f_{u,k,pl,pr}=g_{m+1,k+1,pl,pr}$$

此处 $+1$ 的原因是 $f$ 的定义中是不包含 $u$ 传下去的 $1$ 个子段的。

为了防止当前段被上面**完全覆盖**，将 $f_{u,0,0,1},f_{u,0,1,0},f_{u,0,1,1},f_{u,1,1,1}$ 四个状态设定为不合法。

直接转移是**树背包** $\mathcal{O}(n^2)$ 的，~~可以通过 water235~~。

输出方案考虑在 dp 过程中记录路径，观察转移方式都是用**两个状态**合成一个状态，所以转移的路径可以记作一个**二叉树**的形式，二叉树上的节点代表一个二元组 $(u,i)$ 分别为原树上的节点编号 $u$ 和 $u$ 的一个儿子的排名 $i$，其左儿子为 $(u,i-1)$，右儿子为 $(v_i,m_{v_i}+1)$，需要记录转移时的 $pl,pr$ 以及是否覆盖该儿子的左侧的段。

dp 结束后，将所有的转移都走一遍，模拟线段分配、合并的过程得到方案。

**化简**题目中给出的操作方式对思考解法大有帮助。

## ARC083F Collecting Balls

形如集合 $A$ 中的元素**至多**可以被集合 $B$ 中的元素**选择一次**的关系可以用**无向边**表示，端点代表 $A$，边代表 $B$ 时转化为每个端点可以选择一条边，反之亦然。

用**点**代表机器人，**边**代表球，对于在 $(x,y)$ 上的球，在 $(x,0)$ 和 $(0,y)$ 之间连一条无向边。显然这个图是**基环树森林**，每条边和点都要**一一对应**导致在环上只有**两种**选法（每条边选择顺 $/$ 逆时针方向上的点），而树上的边只能选择**外侧**的点。

在选择的同时还要满足如果 $(x,y)$ 被 $(x,0)$ 选择，$\forall d<y,t_{(0,y)}<t_{(x,0)}$，$t$ 为选择的时刻。

满足偏序关系的序列计数考虑构造一张**有向图**数它的**拓扑序**，可以发现这张有向图一定是**外向树森林**（每个点的入度均为 $1$），套用外向树森林拓扑序数量公式计算。

可以做到 $\mathcal{O}(n)$。

## AGC036D Negative Cycle

要求无向图中**不存在负环**，等价于**差分约束**模型中**存在**一组解。

转换模型，节点 $i$ 代表一个变量 $x_i$。

初始的边**不能删去**，一直存在限制 $x_{i+1}\le x_{i}$，**相邻两数的偏序关系**可以用**差分**表示，相当于 $x_{i}-x_{i+1}\geq 0$，以下将 $x_{i}-x_{i+1}$ 简记为 $q_i$ 于是有 $q_i\geq 0$。

删除的影响不好考虑，**正难则反**转换成最大保留的权值。

如果保留的边 $x\rightarrow y$ 满足 $x<y$ 的话，有 $x_i-x_j\geq 1$，等价于 $\sum_{k=i}^{j-1}q_k\geq 1$。

如果保留的边 $x\rightarrow y$ 满足 $x>y$ 的话，有 $x_j-x_i\le 1$，等价于 $\sum_{k=j}^{i-1}q_k\le 1$。

现在可以分析删除的充要条件~~反过来就只分析了个充要条件~~，对于边 $(i,j)$ 如果 $i<j$，区间和 $\geq 1$ 才能**保留**，相当于区间和 $=0$ 就必须**删除**；如果 $i>j$，区间和 $\le 1$ 才能**保留**，相当于区间和 $\geq 2$ 就必须**删除**。同时由于 $q\geq 0$，左端点相同的区间的区间和是**单调**的，也就是说一段连续的 $q_i=0$ 会导致这个区间内 $i<j$ 边被**删除**；区间和 $>2$ 的区间也会导致区间内 $i>j$ 的边被**删除**。

容易发现 $q_i\geq 2$ 一定**不优于** $q_i<1$，因为 $q_i\geq 2$ 会导致 $i+1\rightarrow i$ 的边被删除，于是 $q\in\{0,1\}$。

上 dp，状态中只需要记录**最近**的两个 $1$ 的位置，设 $dp_{i,j}$ 表示最后一个 $1$ 选在 $i$，倒数第二个选在 $j$ 的最小代价，转移时另外枚举一个 $k$ 表示第三近的位置。

对于 $l\rightarrow r$ 的边，如果 $l\in[1,j],r\in[j+1,i]$ 则会被保留。

对于 $r\rightarrow l$ 的边，如果 $l\in[k+1,i],r\in[j+1,i]$ 则会被保留。

可以用**二维前缀和**优化，时间复杂度 $\mathcal{O}(n^3)$。
