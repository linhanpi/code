---
title: SG函数小记
description: 博弈论小记
katex: true
tags:
  - SG函数小记
categories:
  - 数学
  - 博弈论
  - 知识小记
abbrlink: boyilunxiaoji
sticky: 2
swiper_index: 2
date: 2023-06-19 21:28:03
updated: 2023-06-19 22:00:00
cover: https://cdn.luogu.com.cn/upload/image_hosting/2mc45zx1.png
---
orz cmd orz ，蒟蒻太蒻了只会复读一遍。

{% link command_block 的博客 博弈论小记, https://www.luogu.com.cn/blog/command-block/bo-yi-lun-xiao-ji, https://cdn.luogu.com.cn/upload/usericon/58705.png %}

## 基本框架

### 公平组合游戏

游戏为公平组合游戏是应用 SG 函数的前提，这样的游戏满足以下条件 :

* 两个玩家在面对相同局面时的**所有**可能决策**相同** ( 决策公平 )
* 两个玩家都知晓游戏中所有的信息 ( 无隐藏信息 )
* 游戏中不包含任何随机的要素 ( 无随机过程 )
* 游戏结果**无平局**情况 ( 无平局 )

游戏的状态 $G$ 定义为游戏中的某个局面，某些状态钦定为终止态，最终得到终止态的玩家判负。
玩家的决策构成状态间的转移 $G \rightarrow G^{'}$ ，状态和转移共同构成一张 DAG  ( 若有环则有平局情况 ) ，这张图被称为游戏的博弈图。
一般而言约定游戏双方轮流做出对自己最有利的决策。

### 必胜态与必败态

若一名玩家在面对状态 $G$ 时**存在**使自己必胜的决策，$G$ 便称为游戏的**必胜态**，简记为 $\text{N}$ 态。
相应的若**不存在**使自己必胜的决策，$G$ 为**必败态**，简记为 $\text{P}$ 态。

根据以上定义，可以简单地给出 $\text{N}/\text{P}$ 态的判定 :

* 所有的必败态 $G$ 为 $\text{P}$ 态
* 若 $G$ 的后继状态中存在 $\text{P}$ 态，$G$ 为 $\text{N}$ 态
* 否则 $G$ 为 $\text{P}$ 态

由必败态逆着递推后博弈图中所有的状态都会被标记为 $\text{N}/\text{P}$ 态中的一种，一般采用正向记忆化搜索或建转移的反边拓扑排序处理。

### 带权博弈

游戏中的转移中带着权值，玩家希望最大/小化权值，显然带权博弈严格强于胜负博弈。

直接对抗搜索显然会爆炸，有效状态较少时可以记忆化，但是有效状态总数较多时需要另外的剪枝。

##### P4363 一双木棋 chess

[link](https://www.luogu.com.cn/problem/P4363 "题面 link")

数据范围极小，直接记忆化搜索，难点在寻找合适的状态压缩方式，发现已放的格与未放的格分界线一定是一条从左下到右上的折线，用 $1$ 表示向上 $0$ 表示向右，可以用长为 $n+m$ 的 $01$ 序列表示一个有效的状态，这样分析本质不同的状态只有 $\begin{pmatrix}n+m\\n\end{pmatrix}$ 种，可以通过。
实现时不一定严格按照用于分析的状态进行状压，可以用等价但实现更简单的状压方式。

[code](https://github.com/linhanpi/code/blob/main/code/%E6%9D%82%E9%A2%98/%E5%8D%9A%E5%BC%88%E8%AE%BA/P4363_%E3%80%8C%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018%E3%80%8D_%E4%B8%80%E5%8F%8C%E6%9C%A8%E6%A3%8B_chess.cpp "代码 link")

#### alpha-beta 剪枝

alpha-beta 剪枝用于一方希望最大化权值另一方希望最小化权值时。

将不同的状态转移到的相同局面分开，博弈图变为一颗外向树，由上而下每一层决策为最大/小化权值交替出现，遍历的同时对于每个节点维护 $\alpha$ 表示最大下界，$\beta$ 表示最小上界。
搜索开始时将所有 $\alpha$ 初始化为 $-\infty$ ，$\beta$ 初始化为 $+\infty$，以希望最大化权值为例，进入此状态时继承前驱状态的 $\alpha$ 和 $\beta$ 值，后继状态搜索回溯时更新 $\alpha$ 为当前已遍历的后继状态的 $\alpha$ 最大值 + 当前状态权值，希望最小化更新 $\beta$ 为后继 $\beta$ 最小值 + 当前状态权值即可，当 $\alpha \geq \beta$   时剪枝直接回溯到前驱节点即可。

注意 alpha-beta 剪枝和记忆化是不兼容的。

```cpp
int dfs(int now,int alpha,int beta,bool is_max){
    if(!son[now].size())return val[now];
    if(is_max){
        for(int y:son[now]){
            alpha=val[now]+max(alpha,dfs(y,alpha,beta,is_max^1));
            if(alpha>=beta)break;
        }
        return alpha;
    }
    else{
        for(int y:son[now]){
            beta=val[now]+min(beta,dfs(y,alpha,beta,is_max^1));
            if(alpha>=beta)break;
        }
        return beta;
    }
}
```

## SG 函数与 SG 和

### 定义

SG 函数是判定**公平组合游戏**状态是否是必胜态的简约方法，若 $\mathrm{SG}(G)=0$ 则 $G$ 为必败态，反之为必胜态。

自然有 $\mathrm{SG}(G)=\text{mex} \{\mathrm{SG}(V),V\in T_G\}$ ，其中 $T_{G}$ 为博弈图上 $G$ 的转移。

### SG 和

SG 和提供了当两个人面对多个**独立**的游戏 ( 多个游戏放在一起但一轮只能在其中一个游戏进行决策 ) 时的判定必胜态的简约办法。

对于一个将游戏 $A$ 与 $B$ 独立地组合在一起的游戏状态 $A+B$ ，$\mathrm{SG}(A+B)=\mathrm{SG}(A)  \ \text{xor}\ \mathrm{SG}(B) $ 。
注意到异或的运算规则给出了 SG 和的一个性质 : 两个相同的游戏在计算 SG 和时可以**抵消**，实际运用中常转化为删除一个游戏视为添加一个相同的游戏在运算结果上进行抵消。

**证明** : 咕咕咕

SG 函数的使用一般分四步 :

1. 将游戏拆分为**独立**的部分的组合
2. 先分析所有终止态
3. 使用归纳递推得出单个游戏 SG 函数的简单形式
4. 套用 SG 和的定义组合游戏

##### P5387 人形演舞

[link](https://www.luogu.com.cn/problem/P5387 "题面 link")

> 对一堆大小为 $w$ 的石子，可以做以下操作 :
>
> 选定 $y\leq x$ ，使得 $x{\ \rm xor\ }y<x$ ，并将石子数拿至 $x{\ \rm xor\ }y$。
>
> 两人轮流操作，不能操作者负。
>
> 现在有 $n$ 堆石子，每一堆的大小都在 $[1,m]$ 中，求先手必胜的情况数，答案对 $998244353$ 取模。
>
> $n\leq 10^{18},m\leq 10^6$。

求出先手必胜的充要条件就好计数了，独立性显然，直接冲 SG 和。

终止态显然为 $0$ 。
分析单堆的所有后继状态，对于 $y\leq x$ 的限制，有 $2^k-1=\sum_{i=0}^{k-1} 2^i$ ，在最高位上进行分讨，令 $x=2^k+z,z\in [0,2^k-1]$ 。

* 若 $y \le 2^k$ ，那么 $y$ 可以任选，可以转移到 $2^k+[0,z)$ 。
* 若 $y > 2^k$ ，相当于选定 $y'\le z$ ，使得 $z{\ \rm xor\ }y'<z$ ，规约到子问题 $\mathrm{SG}(z)$。

此时递推预处理是 $\mathcal{O(m^2)}$ 的，打表可以发现 $\mathrm{SG}(x)=z+1$ ，以下用数归给出证明。

对于 $x=2^k$ 的情况，后继状态只有 $0$ ，$\mathrm{SG}(x)=1$ 。
对于 $x>2^k$ 的情况，后继状态有 $2^k+[0,z)$ 以及 $z$ 的后继，则后缀 SG 有 $[0,z]∩[0,\mathrm{SG}(z))$ ，且有 $\mathrm{SG}(z)\le z$ 。
正确性即证。

预处理优化到 $\mathcal{O(m)}$ 。

问题变为在集合 $S$ 中选择 $n$ 次元素，使得异或和非 $0$ 的方案数，使用异或卷积快速幂即可。

可怜的蒟蒻并不会 FWT ，代码就先咕在这里 qwq 。

[code](https://www.bilibili.com/video/BV1GJ411x7h7/ "代码 link")

##### Nim

有 $n$ 堆石子，每轮可以选择其中一堆取出任意个，不能不取，场上没有石子为终止态，求 $\text{N/P}$ 态的判定和必胜策略。

不同堆的石子间是独立的，以堆作为游戏的独立部分进行分析。

对于单堆来说 :

* 终止态 $\mathrm{SG}(0)=0$
* 对于 $k$ 个石子的状态，可以转移到 $1\sim k-1$ 个石子，归纳可得 $\mathrm{SG}(k)=k$

接下来直接套用 SG 和的定义组合多堆，石子数异或和为 $0$ 必败，反之必胜。

必胜策略即构造 SG 和等于 $0$ 的状态送给对面，根据最高位代表的数 $>$ 余下所有位代表数之和的性质，取出二进制下异或和最高位为 $1$ 的数将这一位变为 $0$ ，异或和剩下的位若为 $1$ 则在该位取反即可，根据以上性质，必定符合规定。

##### Take Away

同 Nim 规则，但是一次只能从一堆中取出 $1\sim k$ 个石子。

对于单堆 :

* 终止态 $\mathrm{SG}(0)=0$
* 对于 $n\le k$ 的状态可以规约为 Nim ，$\mathrm{SG}(n)=n$
* 对于 $n > k$ 的状态拿不到 $n\% (k+1)$ ，$\mathrm{SG}(n)=n\%(k+1)$
* 整理可得 $\mathrm{SG}(n)=n\%(k+1)$

对于多堆求异或和即可

##### Hungergame

> 有 $m$ 个箱子，每个箱子中有若干石子，每一轮可以选择下列决策之一 :
>
> * 打开若干箱子
> * 将某个已打开的箱子取出一些石子，不能不取

由于一次可以打开多个箱子，这些游戏不是独立的。
直接从第一次决策开始难以简化问题，分析游戏中途的状态，如果有一些箱子已经被 小A 打开了，不考虑打开箱子的决策游戏弱化为 Nim 游戏。
若此时为 Nim 的 $\text{P}$ 态，那么 小B 不论如何拿石子都不能避免最后进行开箱子的决策，对于在这个 Nim 子游戏中 小B 拿到的所有状态 $G$ ，$\mathrm{SG}(G)=0$ ，小B 想要用打开箱子的操作扭转战局送给对面一个 $\text{P}$ 态的 Nim 子问题唯一的决策是打开一个箱子集合的异或和为 $0$ 。
若存在没打开的集合的异或和为 $0$ ，小B 其实没拿到原游戏中的 $\text{P}$ 态，只有当 小A 没有给 小B 剩下任何集合异或和为 $0$ ，小B 才真正拿到了原游戏中的 $\text{P}$ 态。
因为 $0\ \text{xor}\ 0=0 $，开箱子没有剩下异或和为 $0$ 的集合的充要条件是打开了极大的异或和为 $0$ 的集合。
分析第一次决策，只要打开了极大的异或和为 $0$ 的集合，对面就拿到了 $\text{P}$ 态。
综上只需判定初始状态中是否存在异或和为 $0$ 的集合，使用线性基。

* 某些决策处理时比较麻烦，可以分析已经进行了该决策的状态若去掉这种决策的子游戏的 $\text{N/P}$ 判定方法，而后将这种决策加回来考虑它能否作为拿到子游戏 $\text{P}$ 态的人扭转战局的关键决策，最后分析如何让拿到子游戏 $\text{P}$ 态的人无法使用本决策扭转战局。

##### Staircase

> 有 $n$ 层阶梯，编号 $1\sim n$ ，每层上有一些石子。
>
> 每次操作可以将第 $j$ 层上若干石头放到 $j-1$ 层上,不能不移，第 $0$ 层无法向下移动，终止态为所有石子都在第 $0$ 层上。

不同的阶梯会互相影响，不能直接套用 SG 函数。
弱化问题，只有第 $1$ 层上有石头时，游戏变为单堆的 Nim 。
进一步地，只有第 $2$ 层上有石子时，小A 移动石子到第 $1$ 层后，小B 可以**模仿** 小A 的决策将第一层所有石子都放到第 $0$ 层上，这个过程中先后手不会改变，小B 总是必胜。
推广开来可以发现所有偶数阶梯都不会影响奇数阶梯中的决策，若 小A 尝试将偶数阶梯中的石子移到奇数，小B 只需要紧跟着把这些石子丢到下一个偶数阶梯即可，小B 总是可以最后决策，先后手不会更换。
相当于对于所有的奇数阶梯可以一步将任意多的石子丢到垃圾桶里，等价于 Nim 游戏。

* **模仿**对方的决策可以带来先后手不变的性质，用于证明某些会破坏独立性的决策无用。

##### Take and Break

[P3185 分裂游戏](https://www.luogu.com.cn/problem/P3185 "题面 link")

> 有 $n$ 堆硬币，编号 $1\sim n$ ，第 $i$ 堆有 $p_i$ 个。
>
> 每次操作选择 $3$ 堆硬币 $i,j,k\ (i<j\le k)$ ，从第 $i$ 堆中去掉一枚硬币，向 $j,k$ 中各加入一枚硬币，必败态为无法操作。
>
> 求 $\text{N/P}$ 态的判定。
>
> $1 \leq t \leq 10$，$2 \leq n \leq 21$，$0 \leq p_i \leq 10^4$

思维定势诱导我们对于单堆进行分析，但每堆硬币之间不是独立的，发现每次操作只会选取**一枚**已经在场上的硬币，每枚硬币间其实是互不影响的。

独立地分析一枚硬币，一次操作等于将一枚位置在 $i$ 上的硬币分裂为两枚分别在 $j,k$ 上的硬币，这两枚硬币间也是独立的可以用 SG 和合并，于是就可以对单颗硬币递推出 SG 函数了，预处理时间复杂度 $\mathcal{O(w^3)}$ ，找到了游戏中的独立子问题及其 SG 函数递推方法，余下的询问都是平凡的。

* 每次只操作一个的游戏要素有很大可能可以作为游戏的独立子游戏。
* 一个游戏决策后如果分成两个相互独立的游戏，可以这两个游戏用 SG 和合并当作一个游戏。

[code](https://github.com/linhanpi/code/blob/main/code/%E6%9D%82%E9%A2%98/%E5%8D%9A%E5%BC%88%E8%AE%BA/P3185_%E3%80%8CHNOI2007%E3%80%8D_%E5%88%86%E8%A3%82%E6%B8%B8%E6%88%8F.cpp "代码 link")

##### Turtles Turning

> 一维翻硬币问题，$n$ 个硬币排成一行，有正有反，从左向右按 $1\sim n$ 编号，按照某种规则选取硬币集合翻转，但是受到操作的**最左侧**的硬币必须从正面翻到反面 ( 否则转移可能成环 ) ，本例中每轮可以选择至多两个硬币翻转，终止态为无法操作。

硬币之间初始看是不独立的，分析一次操作的可能状态，令翻转的硬币编号分别为 $i,j\ (i<j)$ ，根据题目限制 $i$ 一定由正面翻到反面，$j$ 若从正面翻到反面等价于从局面中直接删去 $i,j$ ，反之等价于删去 $i$ 后添加 $j$ 。

添加游戏不影响原有游戏间的独立性，但删去游戏是复杂的，返回 SG 和的定义，根据异或的性质，可以等价于添加一个相同的游戏而不去影响原有的游戏，同时也没有影响 SG 和的计算，本题中添加的 $i$ 与原有的 $i$ 抵消，而无论是添加还是删去 $j$ 都可以转化为添加另一个独立的 $j$ 硬币，决策在不同硬币间的后效性被消除，递推 SG 函数即可。

* 删除一个游戏可以视为添加一个相同的游戏在运算结果上进行抵消，好处是将操作在不同游戏间的影响转化为添加一些独立的游戏，保证游戏的独立性。

##### k-Nim

> 规则同 Nim ，但是每一轮可以同时操作 $1\sim k$ 个石堆。

回忆 Nim 游戏中先手若处于 $\text{N}$ 态的决策方法，取出二进制下异或和最高位为 $1$ 的数将这一位变为 $0$ ，异或和剩下的位若为 $1$ 则在该位取反，$2^k-1=\sum_{i=0}^{k-1} 2^i$ 保证了这样决策一定会从一堆石子中取出石子而不是加入，沿用这个性质分析先手的决策，将新异或定义为先将所有数都写成 $2$ 进制的形式无限进制下的**不进位加法**，新异或和判定必败态的方法与原来 $2$ 进制下的相仿，以下论述中可以发现这种定义方式容易推广的优势是明显的。

分析 Nim 游戏过程中中 小A 拿到的状态的新异或和，若所有位上的数都是 $0$ 为 $\text{P}$ 态，每一位上的数最大为 $1$ 为 $\text{N}$ 态，若位全为 $2$ 时为 $\text{P}$ 态，因为对于一位上的 $2$ 无法通过一次操作将它变为 $0$ ，无论怎样操作 小B 都可以通过**模仿**决策将所有的 $1$ 变为 $0$ ，从而使 小A 始终拿到全为 $2$ 的态，最终拿到全 $0$ 态，小A 最好的方案是规避对 $2$ 的操作，将所有的 $1$ 去除，若此时没有 $1$ 则为 $\text{P}$ 态。
推广开发现这个过程很像 staircase ，拿到全偶数态的玩家必败，最终只需考虑所有奇数的位，而一次操作就可以将所有奇数的位变为偶数，每一位对 $2$ 取模判断是否有奇数位即可。

回到本题中 小A 一次决策至多可以进行 $k$ 次这样的操作最终希望使新异或和变为 $0$ ，于是容易发现若 小A 拿到的所有位上均为 $k+1$ 的倍数，小A 不能让 小B 拿到全 $k+1$ 倍数态，小B 却可以通过模仿决策让 小A 最终拿到全 $0$ 态，若有不为 $k+1$ 的倍数的位一次决策就可以使它们全变为 $0$ 。

形式化地，记 $A_i=\sum\limits_{j=0}g_{i,j}*2^j$ ，先手必败当且仅当 $\forall j,\sum_{i=1}^mg_{i,j}\bmod(k+1)=0$ 。

* 可以将异或视为将所有数都写成 $2$ 进制的形式后做无限进制下的不进位加法，最后再分析进制。
* 对于每次同时操作 $k$ 个相仿游戏的组合游戏，可以猜测判定与 $k+1$ 的同余系有关。

### Anti−SG

规则和上文中的公平组合游戏略有不同，规定得到终止态的玩家获胜 ( Anti 规则 ) 。

此时 $\mathrm{SG}(A+B)$ 与 $\mathrm{SG}(A),\mathrm{SG}(B)$ 间没有简约的关系，但是也存在可以判断两个人面对多个**独立**的游戏的简约方法。

##### SJ 定理

设 $G_{1\sim m}$ 为游戏组合中的所有游戏，以 Anti 规则进行，则先手必胜的充要条件为以下两者之一成立 :

* $\text{xor}^{m}_{i=1} \mathrm{SG}(G_i)\neq 0$ 且 $\max^{m}_{i=1} \mathrm{SG}(G_i)>1$
* $\text{xor}^{m}_{i=1} \mathrm{SG}(G_i)= 0$ 且 $\max^{m}_{i=1} \mathrm{SG}(G_i)\le 1$

**证明** : 咕咕咕

##### Misère k-Nim

> 规则同 k-Nim ，但是得到终止态的获胜。

先手必胜的充要条件为以下两者之一成立 :

* 不存在 $>1$ 的石堆，且堆数 $\bmod(k+1)\neq 1$
* 存在 $>1$ 的石堆，且 $\exist j,\sum_{i=1}^mg_{i,j}\bmod(k+1)\neq0$

蒟蒻这回真不会证了 qwq 。

SG 积相关先咕着 ( 好像没啥应用 ) 。
