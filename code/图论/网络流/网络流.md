---
title: 网络流小记
top: 0
toc: true
recommend: 100 
keywords: 网络流
date: 2023-03-11 22:10:43
thumbnail: https://cdn.luogu.com.cn/upload/image_hosting/m8gdxwl3.png
tags: 网络流
categories: [图论:网络流]
my: tulun/wangluoliu
---

## 前言

> 网络流作为图论中思维难度较高的一部分，内容较多且繁杂，为记录梳理网络流的学习，故作此文

---

## $\mathcal{Part\ \mathrm{0}}\ 定义$

* **流网络** $G=\left \langle V,E \right \rangle$ 是一张有向图
* $\forall\ (u,v)\in E\ 有\ (v,u)\notin E$ ，若一条边在流网络中则它的反向边不在此流网络中
* $\forall\ (u,v)\in E$ 有容量函数 $\ c(u,v)\ge 0$，$\forall\ (u,v) \notin E \ 规定\ c(u,v)= 0$
* 规定两个特殊节点 **源点** $st$ ，**汇点** $ed$
* **流** $f$ 是一个定义在 $E$ 上的实值函数满足
  * **容量限制**：$\forall\ (u,v)\in E\ 有\ f(u,v)\le c(u,v)$
  * **流量守恒**：$\forall\ u\in V-\left \{st,ed\right \}\ 有\ \sum_{v\in V}f(v,u) =\sum_{v\in V}f(v,u)$ 除源汇点外入流量等于出流量
  * 定义流 $f$ 的**流量** $\left | f \right | =\ \sum_{v\in V}f(st,v)-\sum_{v\in V}f(v,st)$

## $\mathcal{Part\ \mathrm{1}}\ 基础模板$

### $\mathcal{Part\ \mathrm{1.1}}\ 最大流$

对于一个网络，使整个网络流量最大的流函数被称为网络的**最大流**，此时网络的流量被称为网络的**最大流量**

#### $\mathcal{Part\ 1.1.1}\ \mathsf{EK}\ 增广路算法$

**增广路**是一条从原点 $\mathrm{st}$ 到汇点 $\mathrm{ed}$ 的路径使得流过这条路径可以令流量增加

于是求解最大流就转换成了不断寻找增广路将其加入流中，当图中不存在增广路时此时的流就是最大流

对于网络 $\mathrm{G}$ 和流 $\mathbf{f}$ **残量网络** $\mathrm{G_{\mathbf{f}}}$ 由仍有容量调整流的边构成，形式化的，对于节点对 $\mathrm{u,v\in V}$，定义**剩余容量**如下

$$
\begin{align}\notag
\mathbf{ c_{f}(u,v)} & = \left\{
  \begin{array}{l}
  \mathbf{c(u,v)-f(u,v)} &若(u,v)\in E
  \\ \mathbf{f(v,u)}&若(v,u)\in E
  \\  0&otherwise
  \end{array}\right.
  \end{align}
$$

剩余容量不为 $0$ 的点对构成的边属于残量网络

在**残量网络**上从 $\mathrm{st}$ 进行 $\mathsf{BFS}$ 不断通过剩余容量大于 $0$ 的边直到搜索到 $\mathrm{ed}$ 就找到了一条增广路，记此时增广路上边的最小残存容量为 $\mathbf{f}$ ，将最大流加上 $\mathbf{f}$ ，根据剩余容量的定义，将增广路上的每一条边的剩余容量减去 $\mathbf{f}$ ，反向边的剩余容量加上 $\mathbf{f}$ ，反复执行以上操作直到残量网络上不存在增广路

感性理解反向边允许了以后的增广路对于前面的进行退流，类似于反悔贪心的思想，至于严谨的证明见 $\mathcal{Part\ 1.2.1}\ 最大流最小割定理$

#### $\mathcal{Part\ 1.1.2}\ \mathcal{Dinic}\ 算法$

##### 流程

1. 在残量网络上 $\mathsf{BFS}$ 构造**分层图**，分层图以 $\text{st}$ 到 $\text{x}$ 最少要经过的边数分层，在层数相差为 $1$ 的节点之间连边，显然分层图是一张 **$\text{DAG}$**
2. 在构造出来的分层图上 $\mathsf{DFS}$ 找增广路，在回溯时更新残存容量
3. 不断重复以上步骤直到残量网络中 $\text{st}$ 与 $\text{ed}$ 不连通

加剪枝和优化后，时间复杂度 **$\mathcal{O(n^2m)}$**

#### $\mathcal{Part\ 1.1.3}\ \mathcal{Isap}\ 算法$

##### 流程

1. 从 **$\text{ed}$** **到** **$\text{st}$** 进行一遍 $\mathsf{BFS}$ 构造分层图
2. 从 $\text{st}$ 到 $\text{ed}$ 进行 $\mathsf{DFS}$，当一个点增广结束后，若此时未用完上一个点传下来的流量则将它在分层图上的深度 $+1$ ，如果某个深度没有点，则结束算法
3. 若第 $2$ 步没有结束，则重复第 $2$ 步

[${\large \mathfrak{Code} } $](https://github.com/linhanpi/code/blob/main/code/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/%E6%9C%80%E5%A4%A7%E6%B5%81/%E3%80%8C%E6%A8%A1%E6%9D%BF%E3%80%8D_ISAP.cpp)

### $\mathcal{Part\ 1.2}\ 最小割$

网络 $\mathrm{G}$ 中删除后使得源点 $\mathrm{st}$ 和汇点 $\mathrm{ed}$ 不连通的边集称为**割**

边的容量之和最小的割即**最小割**

#### $\mathcal{Part\ 1.2.1}\ 最大流最小割定理$

咕咕咕，待补:最大流最小割定理

### $\mathcal{Part\ 1.3}\ 费用流$

每条边除了容量限制函数 $\mathbf{c(x,y)}$ ，还有**每单位**流费用 $\mathbf{w(x,y)}$ ，即当某条边上流量为 $\mathbf{f(x,y)}$ 时，这条边费用为 $\mathbf{f(x,y)\times w(x,y)}$ ，流 $\mathbf{f}$ 的费用等于每条边的费用之和

网络中费用最少的最大流被称为**最小费用最大流**

#### $\mathcal{Part\ 1.3.1}\ \mathcal{Dinic}\ 算法$

在 $\mathcal{Dinic}$ 求最大流基础上将 $\mathsf{BFS}$ 换为 $\mathsf{SPFA}$ ,把费用 $\mathbf{w(x,y)}$ 当作边权，在残量网络上求最短路进行分层

注意反向边费用应设置成正向边**相反数**

[${\large \mathfrak{Code} } $](https://github.com/linhanpi/code/blob/main/code/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/%E8%B4%B9%E7%94%A8%E6%B5%81/%E3%80%8C%E6%A8%A1%E6%9D%BF%E3%80%8D_%E5%A4%9A%E8%B7%AF%E5%A2%9E%E5%B9%BFSPFA.cpp)
