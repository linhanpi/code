---
title: 网络流小记
description: hhh
katex: true
tags:
  - 网络流
categories:
  - 图论
abbrlink: wangluoliu
sticky: 2
swiper_index: 2
date: 2023-03-09 18:19:03
updated: 2023-04-06 22:00:00
cover: https://data-static.netdun.net/Fomalhaut/img/dm2.webp
---

## 前言

> 网络流作为图论中思维难度较高的一部分，内容较多且繁杂，为记录梳理网络流的学习，故作此文

---

## Part 0 定义

* **流网络** $G=\left \langle V,E \right \rangle$ 是一张有向图
* $\forall\ (u,v)\in E\ 有\ (v,u)\notin E$ ，若一条边在流网络中则它的反向边不在此流网络中
* $\forall\ (u,v)\in E$ 有容量函数 $\ c(u,v)\ge 0$，$\forall\ (u,v) \notin E \ 规定\ c(u,v)= 0$
* 规定两个特殊节点 **源点** $st$ ，**汇点** $ed$
* **流** $f$ 是一个定义在 $E$ 上的实值函数满足
  * **容量限制**：$\forall\ (u,v)\in E\ 有\ f(u,v)\le c(u,v)$
  * **流量守恒**：$\forall\ u\in V- \left \{st,ed\right \}\ 有\ \sum_{v\in V}f(v,u) =\sum_{v\in V}f(v,u)$ 除源汇点外入流量等于出流量
  * 定义流 $f$ 的**流量** $\left | f \right | =\ \sum_{v\in V}f(st,v)-\sum_{v\in V}f(v,st)$

---

## Part 1 基础模板

### Part 1.1 最大流

对于一个网络，使整个网络流量最大的流函数被称为网络的**最大流**，此时网络的流量被称为网络的**最大流量**

---

#### Part 1.1.1 EK 增广路算法

**增广路**是一条从原点 $st$ 到汇点 $ed$ 的路径使得流过这条路径可以令流量增加

于是求解最大流就转换成了不断寻找增广路将其加入流中，当图中不存在增广路时此时的流就是最大流

对于网络 $G$ 和流 $f$ **残量网络** $G_{f}$ 由仍有容量调整流的边构成，形式化的，对于节点对 $u,v\in V$，定义**剩余容量**如下

$$
\begin{aligned}
 c_{f}(u,v) & = \left\{
  \begin{array}{l}
  c(u,v)-f(u,v) &(u,v)\in E
  \\
  f(v,u)&(v,u)\in E
  \\
  0&otherwise
  \end{array}\right.
  \end{aligned}
$$

剩余容量不为 $0$ 的点对构成的边属于残量网络

在**残量网络**上从 $st$ 进行 BFS 不断通过剩余容量大于 $0$ 的边直到搜索到 $ed$ 就找到了一条增广路，记此时增广路上边的最小残存容量为 $f$ ，将最大流加上 $f$ ，根据剩余容量的定义，将增广路上的每一条边的剩余容量减去 $f$ ，反向边的剩余容量加上 $f$ ，反复执行以上操作直到残量网络上不存在增广路

感性理解反向边允许了以后的增广路对于前面的进行退流，类似于反悔贪心的思想，至于严谨的证明见 Part 1.2.1 最大流最小割定理

观察 EK 算法进行的过程，由于使用 BFS 算法，每次找到的增广路长度应**递增**

#### Part 1.1.2 Dinic 算法

**流程**

1. 在残量网络上 BFS 构造**分层图**，分层图以 $st$ 到 $x$ 最少要经过的边数分层，在层数相差为 $1$ 的节点之间连边，显然分层图是一张 **DAG**
2. 在构造出来的分层图上 DFS 找增广路，在回溯时更新残存容量
3. 不断重复以上步骤直到残量网络中 $st$ 与 $ed$ 不连通

加剪枝和优化后，时间复杂度 **$\mathcal{O(n^2m)}$**

#### Part 1.1.3 Isap 算法

Dinic 基础上通过减少 DFS 和 BFS 的运行次数进行常数优化，时间复杂度同样是 $\mathcal{O(n^2m)}$ ，但随机数据上效率是 Dinic 的 $10$ 倍左右
具体思路是在 DFS 增广时同时将图分层避免大量运行 BFS 和 DFS

**流程**

1. 从 **$ed$** **到** **$st$** 进行一遍 BFS 构造分层图
2. 从 $st$ 到 $ed$ 进行 DFS，当一个点增广结束后，若此时未用完上一个点传下来的流量则将它在分层图上的深度 $+1$ ，如果某个深度没有点，则结束算法
3. 若第 $2$ 步没有结束，则重复第 $2$ 步

[Code](https://github.com/linhanpi/code/blob/main/code/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/%E6%9C%80%E5%A4%A7%E6%B5%81/%E3%80%8C%E6%A8%A1%E6%9D%BF%E3%80%8D_ISAP.cpp)

### Part 1.2 最小割

网络 $G$ 中删除后使得源点 $st$ 和汇点 $ed$ 不连通的边集称为**割**
边的容量之和最小的割即**最小割**

---

#### Part 1.2.1 最大流最小割定理

咕咕咕，待补:最大流最小割定理

### Part 1.3 费用流

每条边除了容量限制函数 $c(x,y)$ ，还有**每单位**流费用 $w(x,y)$ ，即当某条边上流量为 $f(x,y)$ 时，这条边费用为 $f(x,y)\times w(x,y)$ ，流 $f$ 的费用等于每条边的费用之和
网络中费用最少的最大流被称为**最小费用最大流**

---

#### Part 1.3.1 Dinic 算法

在 Dinic 求最大流基础上将 BFS 换为 SPFA ,把费用 $w(x,y)$ 当作边权，在残量网络上求最短路进行分层
注意反向边费用应设置成正向边**相反数**

注意复杂度为 **$\mathcal{O(nmf)}$** ，其中 $f$ 为最大流的大小，看起来是很悬的非多项式复杂度，实际上松松松~

若求解**最大费用最大流**只用将费用设为相反数即可

[Code](https://github.com/linhanpi/code/blob/main/code/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/%E8%B4%B9%E7%94%A8%E6%B5%81/%E3%80%8C%E6%A8%A1%E6%9D%BF%E3%80%8D_%E5%A4%9A%E8%B7%AF%E5%A2%9E%E5%B9%BFSPFA.cpp)

#### Part 1.3.2 有负环的费用流

>[P7173「模板」有负圈的费用流](https://www.luogu.com.cn/problem/P7173)
>
>有负环的费用流模板题

给定一个存在费用为负可能形成负环的网络，给定源汇求最小费用最大流，$n\le 200$，$m\le 10^4$

因为有负环的存在 SPFA 会死的很惨
负环很烦，先把它从图中消去，消去负环一般有两种方法，一种由 Floyd 实现的消圈算法时间复杂度爆炸 $\mathcal{O(n^3)}$，且一定会跑满上界，还有一种用上下界网络流思想实现的，时空复杂度优秀许多，这里采用第二种，~~才不是我不会消圈~~
~~也许需要先理解 Part 1.4 上下界网络流~~

流经负环一定更优，就先使所有负权边满流，残量网络中表现为对于 $\forall\ u \to v$ ，若其费用 $w<0$ 则删去这条边，并连一条边 $v\to u$ 费用为 $-w$

此时流量可能不守恒，仿照上下界思想增加超级源 $st'$ 和超级汇 $ed'$ ，令 $d(u)$ 等于从 $u$ 出发的所有负权边的容量 $-$ 以 $u$ 结束的所有负权边的容量，$\forall\ u \in V ,u\notin st',ed'$，若 $d(u)>0$ ，则连接 $st' \to u$ ，容量为 $d(u)$ ，费用为 $0$ ，若 $d(u)<0$，则连接 $u \to ed'$ ，容量为 $-d(u)$ ，费用同样为 $0$

形式化地，以 $(v,u,f,-w)$ 代替 $(u,v,f,w)$

以**超级源汇**跑一遍最小费用最大流，此时图中不存在负环
再以**原来的源汇**跑一遍最小费用最大流，此时答案即为原图最小费用最大流

#### Part 1.3.3 最大费用任意流 & 正费用最大流

观察 EK 增广的方式，每次都会通过最长路增广，最长路不断缩短，费用具有凸性

利用这一点，对于最大费用任意流，在**单次增广费用**为负时结束即可
对于正费用最大流当**总费用**为负数时结束，注意最后一次增广可能流不满增广路的所有流量

### Part 1.4 上下界网络流
